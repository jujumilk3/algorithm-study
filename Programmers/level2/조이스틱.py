def solution(name):
    make_name = [min(ord(i) - ord('A'), ord('Z') - ord(i)+1) for i in name]
    idx, answer = 0, 0
    while True:
        answer += make_name[idx]
        make_name[idx] = 0
        if sum(make_name) == 0:
            break
        left, right = 1, 1
        while make_name[idx - left] == 0:
            left += 1
        while make_name[idx + right] == 0:
            right += 1
        answer += left if left < right else right
        idx += -left if left < right else right
    return answer


"""
계획: 일단 첫글자는 완성시키고, 완성된 시점에서 모든 글자를 만들 때 소요되는 조이스틱 수를 각각 계산한 다음에
가장 적은 것부터 해결하는 식으로 하면 되겠다.

첫번쨰 실패. 문제를 제대로 안읽어서 커서를 옮길 때마다 무조건 A로 시작하는 게 아니라 전에 J를 썼으면 J부터 시작하는 줄 앎...
두번쨰 실패. 조이스틱의 움직임을 전부 계산해서 움직임을 재현, 움직일 때마다 현재 index에서 아직 글자를 바꾸지 않은 애들 중 움직여야 하는 횟수가
가장 낮은 애들을 찾아서 바꿔주는 걸로. 코드의 복잡성 때문에 런타임 에러가 뜨고 시간이 무쟈게 오래 걸림...
그래거 찾은게 이 코드.

@@ 이하 포스팅 @@

이 문제를 처음 봤을 때 세웠던 계획은 이렇다. 일단 첫글자는 완성시키고, 완성된 시점에서 모든 글자를 만들 때 소요되는 조이스틱 수를 각각 계산한 다음에
가장 적은 것부터 해결하는 식으로 하자! 하지만 실패했다.
첫번째로는 문제를 제대로 안읽어서 실패했다. 난 오락실세대여서 이게 꼭 오락실 마지막에 이름 짓는 것마냥 로직이 그래가 자연스레 오락실 로직을 생각해가지고
자리에 알파벳을 정하면 그 다음 커서에도 해당 알파벳이 있는 채로 시작되는 줄 알았다. 그래서 예제의 "JAZ"를 쓰더라도 J를 쓸 때 스틱 9번, A를 쓸때도
스틱을 9번 움직이게 계산했다. 문제 다시 읽고 지워버렸다.
두번째로는 조이스틱의 움직임을 전부 계산해서 움직임을 재현했고, 움직일 때마다 현재 index에서 아직 글자를 바꾸지 않은 애들 중 움직여야 하는 횟수가
가장 낮은 애들을 찾아서 바꿔주는 걸로 했다. 코드의 복잡성 떄문인지 런타임에러 + 시간이 무쟈게 오래 걸렸다.
그렇게 찾은 게 이 코드이다. 오늘도 보면서 감탄했다...

해당 코드의 진행은 이렇다.
1. make_name으로 각 자리의 알파벳을 만들기 위해 움직여야 하는 최소한의 조이스틱 가동횟수를 구한다.
2. answer에 이 모든 합을 더한다. 이로써 알파벳을 만들기 위한 조이스틱 가동횟수는 모두 구한 것이 된다.
3. 현재 index에서 좌우로 이동방향을 퍼트려 먼저 만나는 방향을 찾는다.
4. 그리고 그 방향만치 인덱스를 새로 조정한다.

정말 감탄이 나온다. 내가 만든 건 장장 수십 줄에 달하면서도 제대로 돌아가지 않는 코드였는데... 너무 슬펐다.
보통 알고리즘 책에서 나오는 게 문제가 실세계에서 작동하는 방식을 상상하면서 만들어보라고 하는 거였는데 이건 그렇게 생각하면
너무 오래걸리고 비효율적인 코드가 된다. 역시 절대적인 건 없다는 생각이 들었다. 이런 류의 문제는 센스가 많이 필요한 것 같다.
"""


print(solution("JEROEN"))
print(solution("JANT"))
print(solution("AJJJZ"))
print(solution("JAAACAAZ"))
